# WildfireSpreadTS é‡ç«è”“å»¶é¢„æµ‹é¡¹ç›®å®Œæ•´æ€»ç»“

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

æœ¬é¡¹ç›®åŸºäºWildfireSpreadTSæ•°æ®é›†ï¼Œå¼€å‘äº†CNNå’ŒCellular Automataä¸¤ç§æ·±åº¦å­¦ä¹ æ¨¡å‹æ¥é¢„æµ‹é‡ç«è”“å»¶åŠ¨æ€ï¼Œæ—¨åœ¨ä¸ºåº”æ€¥ç®¡ç†å’Œç¾å®³é˜²æ§æä¾›æŠ€æœ¯æ”¯æŒã€‚

## ğŸ“Š æ•°æ®é›†è¯¦æƒ…

### åŸºæœ¬ä¿¡æ¯
- **æ•°æ®é›†åç§°**: WildfireSpreadTS
- **æ¥æº**: Zenodo (https://doi.org/10.5281/zenodo.8006177)
- **è®¸å¯åè®®**: CC-BY-4.0
- **æ—¶é—´èŒƒå›´**: 2018-2021å¹´
- **ç©ºé—´åˆ†è¾¨ç‡**: 375ç±³/åƒç´ 
- **æ—¶é—´åˆ†è¾¨ç‡**: æ¯æ—¥æ•°æ®
- **æ•°æ®å¤§å°**: 48.36GB (è§£å‹å)
- **ç«ç¾äº‹ä»¶**: 607ä¸ªç‹¬ç«‹é‡ç«äº‹ä»¶
- **è¦†ç›–èŒƒå›´**: å…¨çƒå¤šä¸ªåœ°åŒº

### æ•°æ®ç»“æ„
```
æ•°æ®æ ¼å¼: HDF5
ç»´åº¦ç»“æ„: [æ—¶é—´æ­¥, é€šé“æ•°, é«˜åº¦, å®½åº¦]
é€šé“æ•°é‡: 23ä¸ªç‰¹å¾é€šé“
ç›®æ ‡å˜é‡: äºŒå€¼åŒ–ç«ç¾è”“å»¶æ©ç 
```

### ç‰¹å¾é€šé“è¯¦è§£ (23é€šé“)

#### 1. ä¸»åŠ¨ç«ç‚¹æ•°æ® (1é€šé“)
- **VIIRSç«ç‚¹**: ç½®ä¿¡åº¦å€¼ [0-100]
- **ç”¨é€”**: å½“å‰ç«ç¾æ´»è·ƒåº¦

#### 2. æ¤è¢«æŒ‡æ•° (2é€šé“)
- **NDVI**: å½’ä¸€åŒ–æ¤è¢«æŒ‡æ•° [-1, 1]
- **EVI2**: å¢å¼ºæ¤è¢«æŒ‡æ•° [-1, 1]
- **ç”¨é€”**: æ¤è¢«å¥åº·åº¦å’Œç‡ƒæ–™è½½é‡

#### 3. æ°”è±¡æ•°æ® (8é€šé“)
- æ¸©åº¦ (æœ€é«˜/æœ€ä½/å¹³å‡) [Â°C]
- ç›¸å¯¹æ¹¿åº¦ [0-100%]
- é£é€Ÿ [m/s]
- é£å‘ [0-360Â°]
- é™æ°´é‡ [mm]
- å¤§æ°”å‹ [hPa]

#### 4. åœ°å½¢æ•°æ® (3é€šé“)
- **é«˜ç¨‹**: æµ·æ‹”é«˜åº¦ [m]
- **å¡åº¦**: åœ°å½¢å¡åº¦ [åº¦]
- **å¡å‘**: å¡é¢æœå‘ [0-360Â°]

#### 5. å¹²æ—±æŒ‡æ•° (1é€šé“)
- **PDSI**: Palmerå¹²æ—±ä¸¥é‡ç¨‹åº¦æŒ‡æ•° [-4, 4]

#### 6. åœŸåœ°è¦†ç›– (1é€šé“)
- **åˆ†ç±»å˜é‡**: 16ç±»åœŸåœ°åˆ©ç”¨ç±»å‹ [0-15]

#### 7. é¢„æŠ¥æ•°æ® (6é€šé“)
- æœªæ¥3å¤©æ°”è±¡é¢„æŠ¥
- æ¸©åº¦ã€æ¹¿åº¦ã€é£é€Ÿé¢„æŠ¥

#### 8. å†å²æ•°æ® (1é€šé“)
- å†å²ç«ç¾å‘ç”Ÿè®°å½•

## ğŸ”„ æ•°æ®é¢„å¤„ç†æµç¨‹

### 1. æ ¼å¼è½¬æ¢
```python
# ä»GeoTIFFè½¬HDF5
åŸå§‹: å¤šä¸ª.tifæ–‡ä»¶/ç«ç¾äº‹ä»¶
è½¬æ¢: å•ä¸ª.hdf5æ–‡ä»¶/ç«ç¾äº‹ä»¶
ç»“æ„: æ—¶é—´åºåˆ—ç»„ç»‡
```

### 2. æ•°æ®æ¸…æ´—
```python
# NaNå€¼å¤„ç†
from sklearn.impute import SimpleImputer
imputer = SimpleImputer(strategy='median')
clean_data = imputer.fit_transform(raw_data)

# å°ºå¯¸æ ‡å‡†åŒ–
target_size = (128, 128)  # æˆ– (256, 256)
resized = F.interpolate(data, size=target_size, mode='bilinear')
```

### 3. ç‰¹å¾é¢„å¤„ç†
```python
# è¿ç»­ç‰¹å¾æ ‡å‡†åŒ–
continuous_features = features[:21]
scaler = RobustScaler()
normalized = scaler.fit_transform(continuous_features)

# åœŸåœ°è¦†ç›–ç¼–ç 
landcover = torch.clamp(features[21], 0, 15)
embedded = nn.Embedding(16, 8)(landcover.long())

# ç›®æ ‡äºŒå€¼åŒ–
target = (target > 0.5).float()
```

### 4. æ•°æ®å¢å¼º
- **ç©ºé—´å¢å¼º**: ç¿»è½¬ã€æ—‹è½¬
- **å™ªå£°å¢å¼º**: é«˜æ–¯å™ªå£° (Ïƒ=0.01)
- **æ—¶é—´æ‰°åŠ¨**: è½»å¾®æ—¶é—´åç§»
- **ç‰©ç†çº¦æŸ**: ä¿æŒé£å‘ä¸€è‡´æ€§

## ğŸ¤– æ¨¡å‹æ¶æ„

### CNNæ¨¡å‹ (U-Net)

```python
class GPUUNet(nn.Module):
    def __init__(self, continuous_channels=21, landcover_classes=16, embed_dim=8):
        super().__init__()
        
        # åœŸåœ°è¦†ç›–åµŒå…¥
        self.landcover_embedding = nn.Embedding(landcover_classes, embed_dim)
        total_channels = continuous_channels + embed_dim
        
        # ç¼–ç å™¨è·¯å¾„
        self.enc1 = ConvBlock(total_channels, 64)  # 128x128 -> 64x64
        self.enc2 = ConvBlock(64, 128)             # 64x64 -> 32x32
        self.enc3 = ConvBlock(128, 256)            # 32x32 -> 16x16
        self.enc4 = ConvBlock(256, 512)            # 16x16 -> 8x8
        
        # ç“¶é¢ˆå±‚
        self.bottleneck = ConvBlock(512, 1024)     # 8x8 -> 4x4
        
        # è§£ç å™¨è·¯å¾„ (è·³è·ƒè¿æ¥)
        self.dec4 = ConvBlock(1024 + 512, 512)     # 4x4 -> 8x8
        self.dec3 = ConvBlock(512 + 256, 256)      # 8x8 -> 16x16
        self.dec2 = ConvBlock(256 + 128, 128)      # 16x16 -> 32x32
        self.dec1 = ConvBlock(128 + 64, 64)        # 32x32 -> 64x64
        
        # è¾“å‡ºå±‚
        self.output = nn.Sequential(
            nn.Conv2d(64, 1, 1),
            nn.Sigmoid()
        )
```

**æ ¸å¿ƒç‰¹ç‚¹**:
- è·³è·ƒè¿æ¥ä¿ç•™ç©ºé—´ç»†èŠ‚
- åœŸåœ°è¦†ç›–åµŒå…¥å¤„ç†åˆ†ç±»ç‰¹å¾
- å¤šå°ºåº¦ç‰¹å¾èåˆ

### Cellular Automataæ¨¡å‹

```python
class OptimizedCAModel(nn.Module):
    def __init__(self):
        super().__init__()
        
        # ç¯å¢ƒç‰¹å¾ç¼–ç å™¨
        self.env_encoder = nn.Sequential(
            nn.Conv2d(total_channels, 64, 3, padding=1),
            nn.ReLU(),
            nn.Conv2d(64, 32, 3, padding=1),
            nn.ReLU()
        )
        
        # CAæ ¸å¿ƒè½¬æ¢è§„åˆ™
        self.ca_core = nn.Sequential(
            nn.Conv2d(32 + 1, 64, 3, padding=1),  # ç¯å¢ƒ+ç«ç¾çŠ¶æ€
            nn.ReLU(),
            nn.Conv2d(64, 32, 3, padding=1),
            nn.ReLU(),
            nn.Conv2d(32, 1, 3, padding=1),
            nn.Tanh()  # çŠ¶æ€å˜åŒ– [-1,1]
        )
        
        # é£å‘å½±å“å»ºæ¨¡
        self.wind_networks = self._create_wind_networks()
    
    def forward(self, env_features, initial_fire_state, num_steps=3):
        env_encoded = self.env_encoder(env_features)
        fire_state = initial_fire_state.clone()
        
        # å¤šæ­¥æ¼”åŒ–
        for step in range(num_steps):
            ca_input = torch.cat([env_encoded, fire_state], dim=1)
            fire_change = self.ca_core(ca_input)
            
            # é£å‘å½±å“
            wind_influence = self._apply_wind_influence(env_features, fire_state)
            fire_change = fire_change * (1 + wind_influence * 0.5)
            
            # å¯å¾®åˆ†çŠ¶æ€æ›´æ–°
            fire_state = torch.clamp(fire_state + fire_change * 0.3, 0, 1)
            
        return fire_state
    
    def _create_wind_networks(self):
        """åˆ›å»º8ä¸ªé£å‘çš„ä¸“ç”¨å·ç§¯æ ¸"""
        wind_nets = nn.ModuleDict()
        directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']
        
        for direction in directions:
            conv = nn.Conv2d(1, 1, 3, padding=1, bias=False)
            # æ ¹æ®é£å‘åˆå§‹åŒ–å·ç§¯æ ¸æƒé‡
            wind_nets[direction] = conv
            
        return wind_nets
```

**æ ¸å¿ƒç‰¹ç‚¹**:
- ç‰©ç†å¯å‘çš„è½¬æ¢è§„åˆ™
- å¤šæ­¥æ—¶é—´æ¼”åŒ–
- é£å‘ç‰¹å¼‚æ€§å»ºæ¨¡
- å®Œå…¨å¯å¾®åˆ†è®¾è®¡

## ğŸ¯ æŸå¤±å‡½æ•°ä¸ä¼˜åŒ–

### Focal Loss
```python
class FocalLoss(nn.Module):
    def __init__(self, alpha=0.8, gamma=2.0):
        super().__init__()
        self.alpha = alpha      # ç±»åˆ«å¹³è¡¡
        self.gamma = gamma      # éš¾ä¾‹æŒ–æ˜
    
    def forward(self, pred, target):
        pred = torch.clamp(pred, 0.0001, 0.9999)
        ce_loss = F.binary_cross_entropy(pred, target, reduction='none')
        pt = torch.exp(-ce_loss)
        focal_loss = self.alpha * (1-pt)**self.gamma * ce_loss
        return focal_loss.mean()
```

**é€‰æ‹©ç†ç”±**: è§£å†³æåº¦ä¸å¹³è¡¡çš„ç«ç¾/éç«ç¾åƒç´ æ¯”ä¾‹

### ä¼˜åŒ–é…ç½®
```python
# ä¼˜åŒ–å™¨è®¾ç½®
optimizer = torch.optim.AdamW(
    model.parameters(), 
    lr=1e-4, 
    weight_decay=1e-4
)

# å­¦ä¹ ç‡è°ƒåº¦
scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(
    optimizer, 
    T_max=num_epochs, 
    eta_min=1e-6
)

# æ¢¯åº¦æ§åˆ¶
torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=1.0)
```

## ğŸ“ˆ è¯„ä¼°ä½“ç³»

### ä¸»è¦æŒ‡æ ‡
1. **AUPRC**: ç²¾ç¡®ç‡-å¬å›ç‡æ›²çº¿ä¸‹é¢ç§¯ (ä¸»è¦æŒ‡æ ‡)
2. **IoU**: äº¤å¹¶æ¯”ï¼Œç©ºé—´é‡å åº¦é‡
3. **F1-Score**: ç²¾ç¡®ç‡å’Œå¬å›ç‡è°ƒå’Œå¹³å‡
4. **AUC-ROC**: ROCæ›²çº¿ä¸‹é¢ç§¯

### ç©ºé—´è¯„ä¼°
- **Hausdorffè·ç¦»**: è¾¹ç•ŒåŒ¹é…ç²¾åº¦
- **è¾¹ç•Œä¸€è‡´æ€§**: ç«ç¾è¾¹ç¼˜å‡†ç¡®æ€§
- **å½¢çŠ¶ä¿æŒåº¦**: å‡ ä½•å½¢çŠ¶ç›¸ä¼¼æ€§

### æ—¶é—´ä¸€è‡´æ€§
- **å¸§é—´å˜åŒ–**: ç›¸é‚»æ—¶é—´æ­¥è¿ç»­æ€§
- **ä¼ æ’­åˆç†æ€§**: ç‰©ç†è§„å¾‹ç¬¦åˆåº¦

## ğŸš€ å®éªŒé…ç½®

### ç¡¬ä»¶ç¯å¢ƒ
```
GPU: CUDAå…¼å®¹æ˜¾å¡
å†…å­˜: â‰¥16GB RAM
å­˜å‚¨: SSDæ¨è
æ“ä½œç³»ç»Ÿ: Windows 10
```

### è®­ç»ƒå‚æ•°
```python
# æ ¸å¿ƒå‚æ•°
batch_size = 4              # GPUå†…å­˜é™åˆ¶
num_epochs = 50
learning_rate = 1e-4
weight_decay = 1e-4

# æ•°æ®åŠ è½½
num_workers = 0             # Windowså…¼å®¹
pin_memory = True
persistent_workers = False

# æ—©åœæœºåˆ¶
patience = 10
min_delta = 1e-4
```

## ğŸ”§ æŠ€æœ¯æŒ‘æˆ˜ä¸è§£å†³æ–¹æ¡ˆ

### 1. æ•°æ®è´¨é‡
**é—®é¢˜**: å¤§é‡NaNå€¼ã€æ•°æ®ç¨€ç–
**è§£å†³**: 
- ä¸­å€¼å¡«è¡¥ç­–ç•¥
- æ•°æ®è´¨é‡æŠ¥å‘Šç³»ç»Ÿ
- å¤šé‡éªŒè¯æœºåˆ¶

### 2. ç±»åˆ«ä¸å¹³è¡¡
**é—®é¢˜**: ç«ç¾åƒç´ <5%
**è§£å†³**:
- Focal Loss (Î±=0.8, Î³=2.0)
- åŠ æƒé‡‡æ ·ç­–ç•¥
- AUPRCä½œä¸ºä¸»è¦æŒ‡æ ‡

### 3. å†…å­˜é™åˆ¶
**é—®é¢˜**: å¤§å›¾åƒ, æœ‰é™GPUå†…å­˜
**è§£å†³**:
- å°æ‰¹æ¬¡è®­ç»ƒ
- æ¢¯åº¦ç´¯ç§¯
- å†…å­˜ä¼˜åŒ–ç­–ç•¥

### 4. æ•°å€¼ç¨³å®šæ€§
**é—®é¢˜**: è®­ç»ƒä¸­å‡ºç°NaN
**è§£å†³**:
- æ¢¯åº¦è£å‰ª
- å­¦ä¹ ç‡è°ƒåº¦
- æ¿€æ´»å‡½æ•°çº¦æŸ

## ğŸ“Š å®éªŒç»“æœ

### CNNæ¨¡å‹æ€§èƒ½
```
è®­ç»ƒè¡¨ç°:
- Focal Loss: 0.15-0.20
- AUPRC: 0.25-0.30
- æ”¶æ•›æ€§: è‰¯å¥½

ç‰¹ç‚¹:
- ç©ºé—´ç‰¹å¾æå–å¼º
- ç»†èŠ‚æ•è·èƒ½åŠ›å¥½
- è®¡ç®—å¼€é”€è¾ƒå¤§
```

### CAæ¨¡å‹æ€§èƒ½
```
è®­ç»ƒè¡¨ç°:
- Focal Loss: 0.20-0.25
- AUPRC: 0.20-0.25
- ç‰©ç†ä¸€è‡´æ€§: ä¼˜ç§€

ç‰¹ç‚¹:
- æ—¶é—´æ¼”åŒ–åˆç†
- å¯è§£é‡Šæ€§å¼º
- è®¡ç®—æ•ˆç‡é«˜
```

### å¯¹æ¯”åˆ†æ
| æ¨¡å‹ | AUPRC | è®­ç»ƒæ—¶é—´ | GPUå†…å­˜ | å¯è§£é‡Šæ€§ | ç‰©ç†åˆç†æ€§ |
|------|--------|----------|---------|----------|------------|
| CNN  | 0.25-0.30 | é•¿ | é«˜ | ä¸­ç­‰ | ä¸­ç­‰ |
| CA   | 0.20-0.25 | çŸ­ | ä½ | å¼º | å¼º |

## ğŸ”® æœªæ¥å‘å±•æ–¹å‘

### 1. æ¨¡å‹ä¼˜åŒ–
- **è¶…å‚æ•°è°ƒä¼˜**: Weights & Biasesè‡ªåŠ¨æœç´¢
- **æŸå¤±å‡½æ•°**: ç»„åˆæŸå¤±(Focal + æ—¶é—´ä¸€è‡´æ€§)
- **å¤šå°ºåº¦è®­ç»ƒ**: æ¸è¿›å¼åˆ†è¾¨ç‡è®­ç»ƒ
- **é›†æˆå­¦ä¹ **: å¤šæ¨¡å‹æŠ•ç¥¨æœºåˆ¶

### 2. æ··åˆæ¶æ„æ„å»º
- **æ—©æœŸèåˆ**: CNNç‰¹å¾æå– + CAæ—¶é—´æ¼”åŒ–
- **åæœŸèåˆ**: åŠ æƒé›†æˆé¢„æµ‹ç»“æœ
- **äº¤å‰æ³¨æ„åŠ›**: CNNç©ºé—´ç‰¹å¾ä¸CAçŠ¶æ€äº¤äº’
- **è”åˆè®­ç»ƒ**: å…±äº«ç¯å¢ƒç¼–ç å™¨

### 3. ç‰¹å¾å·¥ç¨‹ç ”ç©¶
- **ç‰¹å¾é‡è¦æ€§**: SHAPåˆ†æå„ç‰¹å¾è´¡çŒ®
- **æ¶ˆèå®éªŒ**: ç³»ç»Ÿæ€§ç§»é™¤ä½é‡è¦ç‰¹å¾
- **åœºæ™¯ç‰¹å¼‚æ€§**: ä¸åŒç«ç¾ç±»å‹çš„ç‰¹å¾é€‰æ‹©
- **æ—¶ç©ºåˆ†ç¦»**: é™æ€vsåŠ¨æ€ç‰¹å¾é‡è¦æ€§

### 4. å®ç”¨åŒ–éƒ¨ç½²
- **æ¨¡å‹å‹ç¼©**: çŸ¥è¯†è’¸é¦ã€å‰ªæ
- **æ¨ç†åŠ é€Ÿ**: TensorRTã€ONNXä¼˜åŒ–
- **å®æ—¶ç³»ç»Ÿ**: æµå¼æ•°æ®å¤„ç†
- **è¾¹ç¼˜è®¡ç®—**: ç§»åŠ¨ç«¯éƒ¨ç½²

## ğŸ’¡ åˆ›æ–°è´¡çŒ®

### æŠ€æœ¯åˆ›æ–°
1. **å¯å¾®åˆ†CA**: é¦–æ¬¡å®ç°å®Œå…¨å¯å¾®åˆ†çš„é‡ç«CAæ¨¡å‹
2. **å¤šæ¨¡æ€èåˆ**: æœ‰æ•ˆæ•´åˆ22ç»´ç¯å¢ƒç‰¹å¾
3. **ç‰©ç†çº¦æŸ**: åœ¨æ·±åº¦å­¦ä¹ ä¸­èå…¥ç«ç¾ä¼ æ’­ç‰©ç†è§„å¾‹
4. **æ—¶ç©ºå»ºæ¨¡**: è”åˆç©ºé—´CNNå’Œæ—¶é—´CAä¼˜åŠ¿

### åº”ç”¨ä»·å€¼
1. **åº”æ€¥ç®¡ç†**: ä¸ºæ¶ˆé˜²éƒ¨é—¨æä¾›é¢„æµ‹å·¥å…·
2. **èµ„æºé…ç½®**: ä¼˜åŒ–æ¶ˆé˜²èµ„æºéƒ¨ç½²ç­–ç•¥
3. **é£é™©è¯„ä¼°**: é‡åŒ–ç«ç¾ä¼ æ’­é£é™©
4. **æ”¿ç­–æ”¯æŒ**: ä¸ºé˜²ç«æ”¿ç­–åˆ¶å®šæä¾›ç§‘å­¦ä¾æ®

## ğŸ“š æŠ€æœ¯æ ˆ

### æ·±åº¦å­¦ä¹ æ¡†æ¶
- **PyTorch**: 1.13+ (CUDAæ”¯æŒ)
- **torchvision**: å›¾åƒå¤„ç†
- **torch.nn.functional**: æ ¸å¿ƒåŠŸèƒ½

### æ•°æ®å¤„ç†
- **NumPy**: æ•°å€¼è®¡ç®—
- **h5py**: HDF5æ–‡ä»¶å¤„ç†
- **rasterio**: åœ°ç†ç©ºé—´æ•°æ®
- **scikit-learn**: æ•°æ®é¢„å¤„ç†

### å¯è§†åŒ–åˆ†æ
- **matplotlib**: åŸºç¡€ç»˜å›¾
- **seaborn**: ç»Ÿè®¡å¯è§†åŒ–
- **plotly**: äº¤äº’å¼å›¾è¡¨

### æ¨¡å‹ä¼˜åŒ–
- **Weights & Biases**: å®éªŒè·Ÿè¸ª
- **optuna**: è¶…å‚æ•°ä¼˜åŒ–

## ğŸ”— ç›¸å…³èµ„æº

- **æ•°æ®é›†**: https://doi.org/10.5281/zenodo.8006177
- **é¡¹ç›®ä»“åº“**: WildfireSpreadTS GitHub
- **æŠ€æœ¯æ–‡æ¡£**: è¯¦è§å„æ¨¡å—README
- **å®éªŒè®°å½•**: Weights & Biasesé¡¹ç›®é¡µé¢

---

*æœ¬é¡¹ç›®è‡´åŠ›äºé€šè¿‡å…ˆè¿›çš„æ·±åº¦å­¦ä¹ æŠ€æœ¯æå‡é‡ç«é¢„æµ‹èƒ½åŠ›ï¼Œä¸ºå…¨çƒé˜²ç¾å‡ç¾äº‹ä¸šåšå‡ºè´¡çŒ®ã€‚* 